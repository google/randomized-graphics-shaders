[[block]]
struct buf1 {
  resolution : vec2<f32>;
};

[[block]]
struct buf0 {
  injectionSwitch : vec2<f32>;
};

[[group(0), binding(1)]] var<uniform> x_297 : buf1;

var<private> gl_FragCoord : vec4<f32>;

var<private> x_GLF_color : vec4<f32>;

[[group(0), binding(0)]] var<uniform> x_371 : buf0;

fn nb_mod_f1_f1_(limit : ptr<function, f32>, ref : ptr<function, f32>) -> f32 {
  var s : f32;
  var i : i32;
  var GLF_live0_looplimiter0 : i32;
  var GLF_live0pos : vec2<i32>;
  var indexable : array<i32, 256u>;
  var indexable_1 : array<i32, 256u>;
  var GLF_live0p : f32;
  var indexable_2 : array<i32, 256u>;
  s = 0.0;
  i = 1;
  loop {
    let x_24 : i32 = i;
    if ((x_24 < 800)) {
    } else {
      break;
    }
    let x_28 : i32 = i;
    let x_30 : f32 = *(ref);
    if (((f32(x_28) - (x_30 * floor((f32(x_28) / x_30)))) <= 0.01)) {
      let x_37 : f32 = s;
      s = (x_37 + 0.200000003);
    }
    let x_39 : i32 = i;
    let x_41 : f32 = *(limit);
    if ((f32(x_39) >= x_41)) {
      let x_45 : f32 = s;
      return x_45;
    }

    continuing {
      let x_47 : i32 = i;
      i = (x_47 + 1);
    }
  }
  GLF_live0_looplimiter0 = 0;
  GLF_live0pos = vec2<i32>(49019, -64799);
  loop {
    var x_259 : bool;
    var x_260_phi : bool;
    let x_65 : i32 = GLF_live0pos.y;
    if ((x_65 != 256)) {
    } else {
      break;
    }
    let x_68 : i32 = GLF_live0_looplimiter0;
    if ((x_68 >= 5)) {
      break;
    }
    let x_74 : i32 = GLF_live0_looplimiter0;
    GLF_live0_looplimiter0 = (x_74 + 1);
    let x_78 : i32 = GLF_live0pos.x;
    let x_239 : i32 = GLF_live0pos.y;
    indexable = array<i32, 256u>(115, 133, 150, 164, 176, 184, 190, 192, 191, 187, 181, 172, 163, 153, 143, 134, 126, 120, 116, 114, 114, 117, 121, 127, 134, 141, 148, 154, 159, 162, 163, 161, 157, 151, 143, 134, 124, 113, 103, 94, 87, 82, 79, 80, 84, 91, 101, 114, 130, 146, 164, 182, 199, 215, 229, 240, 249, 254, 256, 254, 250, 243, 233, 223, 212, 200, 190, 180, 172, 166, 163, 161, 162, 164, 169, 174, 179, 185, 190, 193, 195, 195, 192, 188, 180, 171, 161, 149, 137, 125, 114, 105, 97, 93, 91, 93, 98, 106, 117, 130, 145, 161, 177, 193, 208, 221, 231, 239, 243, 244, 242, 236, 228, 218, 207, 194, 181, 169, 158, 148, 141, 135, 132, 131, 132, 135, 138, 143, 147, 151, 154, 155, 155, 152, 146, 139, 129, 118, 106, 93, 80, 68, 58, 49, 43, 40, 41, 44, 51, 61, 73, 87, 103, 119, 134, 149, 162, 173, 181, 186, 188, 186, 181, 174, 164, 153, 141, 128, 116, 104, 94, 86, 81, 77, 76, 77, 80, 84, 89, 94, 98, 102, 104, 104, 102, 98, 92, 83, 73, 62, 50, 38, 26, 16, 8, 2, 0, 0, 4, 11, 21, 33, 48, 64, 81, 98, 114, 129, 141, 151, 158, 161, 161, 158, 152, 144, 134, 123, 112, 100, 90, 81, 73, 68, 65, 65, 67, 70, 75, 81, 87, 92, 97, 101, 103, 102, 100, 95, 88, 79, 69, 58, 47, 36, 26, 18, 13, 11, 11, 15, 22, 32, 45, 60, 77, 94);
    let x_245 : i32 = indexable[clamp(x_239, 0, 255)];
    let x_247 : bool = (x_78 < (x_245 + 15));
    x_260_phi = x_247;
    if (x_247) {
      let x_251 : i32 = GLF_live0pos.x;
      let x_253 : i32 = GLF_live0pos.y;
      indexable_1 = array<i32, 256u>(115, 133, 150, 164, 176, 184, 190, 192, 191, 187, 181, 172, 163, 153, 143, 134, 126, 120, 116, 114, 114, 117, 121, 127, 134, 141, 148, 154, 159, 162, 163, 161, 157, 151, 143, 134, 124, 113, 103, 94, 87, 82, 79, 80, 84, 91, 101, 114, 130, 146, 164, 182, 199, 215, 229, 240, 249, 254, 256, 254, 250, 243, 233, 223, 212, 200, 190, 180, 172, 166, 163, 161, 162, 164, 169, 174, 179, 185, 190, 193, 195, 195, 192, 188, 180, 171, 161, 149, 137, 125, 114, 105, 97, 93, 91, 93, 98, 106, 117, 130, 145, 161, 177, 193, 208, 221, 231, 239, 243, 244, 242, 236, 228, 218, 207, 194, 181, 169, 158, 148, 141, 135, 132, 131, 132, 135, 138, 143, 147, 151, 154, 155, 155, 152, 146, 139, 129, 118, 106, 93, 80, 68, 58, 49, 43, 40, 41, 44, 51, 61, 73, 87, 103, 119, 134, 149, 162, 173, 181, 186, 188, 186, 181, 174, 164, 153, 141, 128, 116, 104, 94, 86, 81, 77, 76, 77, 80, 84, 89, 94, 98, 102, 104, 104, 102, 98, 92, 83, 73, 62, 50, 38, 26, 16, 8, 2, 0, 0, 4, 11, 21, 33, 48, 64, 81, 98, 114, 129, 141, 151, 158, 161, 161, 158, 152, 144, 134, 123, 112, 100, 90, 81, 73, 68, 65, 65, 67, 70, 75, 81, 87, 92, 97, 101, 103, 102, 100, 95, 88, 79, 69, 58, 47, 36, 26, 18, 13, 11, 11, 15, 22, 32, 45, 60, 77, 94);
      let x_257 : i32 = indexable_1[clamp(x_253, 0, 255)];
      x_259 = (x_251 > (x_257 - 15));
      x_260_phi = x_259;
    }
    let x_260 : bool = x_260_phi;
    if (x_260) {
      let x_266 : i32 = GLF_live0pos.x;
      let x_268 : i32 = GLF_live0pos.y;
      indexable_2 = array<i32, 256u>(115, 133, 150, 164, 176, 184, 190, 192, 191, 187, 181, 172, 163, 153, 143, 134, 126, 120, 116, 114, 114, 117, 121, 127, 134, 141, 148, 154, 159, 162, 163, 161, 157, 151, 143, 134, 124, 113, 103, 94, 87, 82, 79, 80, 84, 91, 101, 114, 130, 146, 164, 182, 199, 215, 229, 240, 249, 254, 256, 254, 250, 243, 233, 223, 212, 200, 190, 180, 172, 166, 163, 161, 162, 164, 169, 174, 179, 185, 190, 193, 195, 195, 192, 188, 180, 171, 161, 149, 137, 125, 114, 105, 97, 93, 91, 93, 98, 106, 117, 130, 145, 161, 177, 193, 208, 221, 231, 239, 243, 244, 242, 236, 228, 218, 207, 194, 181, 169, 158, 148, 141, 135, 132, 131, 132, 135, 138, 143, 147, 151, 154, 155, 155, 152, 146, 139, 129, 118, 106, 93, 80, 68, 58, 49, 43, 40, 41, 44, 51, 61, 73, 87, 103, 119, 134, 149, 162, 173, 181, 186, 188, 186, 181, 174, 164, 153, 141, 128, 116, 104, 94, 86, 81, 77, 76, 77, 80, 84, 89, 94, 98, 102, 104, 104, 102, 98, 92, 83, 73, 62, 50, 38, 26, 16, 8, 2, 0, 0, 4, 11, 21, 33, 48, 64, 81, 98, 114, 129, 141, 151, 158, 161, 161, 158, 152, 144, 134, 123, 112, 100, 90, 81, 73, 68, 65, 65, 67, 70, 75, 81, 87, 92, 97, 101, 103, 102, 100, 95, 88, 79, 69, 58, 47, 36, 26, 18, 13, 11, 11, 15, 22, 32, 45, 60, 77, 94);
      let x_272 : i32 = indexable_2[clamp(x_268, 0, 255)];
      GLF_live0p = ((15.0 - abs(f32((x_266 - x_272)))) / 15.0);
      let x_278 : f32 = GLF_live0p;
      let x_279 : f32 = GLF_live0p;
      let x_280 : f32 = GLF_live0p;
      let x_283 : vec4<f32> = vec4<f32>(x_278, x_279, x_280, 1.0);
    }
    let x_284 : ptr<function, i32> = &(GLF_live0pos.y);
    let x_285 : i32 = *(x_284);
    *(x_284) = (x_285 + 1);
  }
  let x_287 : f32 = s;
  return x_287;
}

fn main_1() {
  var c : vec4<f32>;
  var ref_1 : f32;
  var param : f32;
  var param_1 : f32;
  var param_2 : f32;
  var param_3 : f32;
  var i_1 : i32;
  c = vec4<f32>(0.0, 0.0, 0.0, 1.0);
  let x_300 : f32 = x_297.resolution.x;
  ref_1 = floor((x_300 / 8.0));
  let x_309 : f32 = gl_FragCoord.x;
  param = x_309;
  let x_311 : f32 = ref_1;
  param_1 = x_311;
  let x_312 : f32 = nb_mod_f1_f1_(&(param), &(param_1));
  c.x = x_312;
  let x_316 : f32 = gl_FragCoord.y;
  param_2 = x_316;
  let x_318 : f32 = ref_1;
  param_3 = x_318;
  let x_319 : f32 = nb_mod_f1_f1_(&(param_2), &(param_3));
  c.y = x_319;
  let x_322 : f32 = c.x;
  let x_324 : f32 = c.y;
  c.z = (x_322 + x_324);
  i_1 = 0;
  loop {
    let x_334 : i32 = i_1;
    if ((x_334 < 3)) {
    } else {
      break;
    }
    let x_337 : i32 = i_1;
    let x_339 : f32 = c[x_337];
    if ((x_339 >= 1.0)) {
      let x_343 : i32 = i_1;
      let x_344 : i32 = i_1;
      let x_346 : f32 = c[x_344];
      let x_347 : i32 = i_1;
      let x_349 : f32 = c[x_347];
      c[x_343] = (x_346 * x_349);
    }

    continuing {
      let x_352 : i32 = i_1;
      i_1 = (x_352 + 1);
    }
  }
  let x_355 : f32 = c.x;
  c.x = (x_355 - (1.0 * floor((x_355 / 1.0))));
  let x_359 : f32 = c.y;
  c.y = (x_359 - (1.0 * floor((x_359 / 1.0))));
  let x_363 : f32 = c.z;
  c.z = (x_363 - (1.0 * floor((x_363 / 1.0))));
  let x_368 : vec4<f32> = c;
  x_GLF_color = x_368;
  return;
}

struct main_out {
  [[location(0)]]
  x_GLF_color_1 : vec4<f32>;
};

[[stage(fragment)]]
fn main([[builtin(position)]] gl_FragCoord_param : vec4<f32>) -> main_out {
  gl_FragCoord = gl_FragCoord_param;
  main_1();
  return main_out(x_GLF_color);
}
