[[block]]
struct buf0 {
    time: f32;
};

[[block]]
struct buf1 {
    resolution: vec2<f32>;
};

var<private> b_b: f32;
var<private> s_g: f32;
var<private> h_r: f32;
[[group(0), binding(0)]]
var<uniform> global: buf0;
[[group(0), binding(1)]]
var<uniform> global1: buf1;
var<private> gl_FragCoord1: vec4<f32>;
var<private> GLF_color: vec4<f32>;
var<private> global2: f32 = 0.0;
var<private> global3: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
var<private> global4: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
var<private> global5: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
var<private> global6: u32 = 0u;
var<private> global7: u32 = 0u;
var<private> global8: vec2<f32> = vec2<f32>(0.0, 0.0);
var<private> global9: f32 = 0.0;
var<private> global10: f32 = 0.0;
var<private> global11: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
var<private> global12: vec2<f32> = vec2<f32>(0.0, 0.0);
var<private> global13: u32 = 0u;
var<private> global14: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
var<private> global15: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
var<private> global16: u32 = 0u;
var<private> global17: bool = false;
var<private> global18: vec2<f32> = vec2<f32>(0.0, 0.0);
var<private> global19: u32 = 0u;
var<private> global20: vec2<f32> = vec2<f32>(0.0, 0.0);
var<private> global21: vec2<f32> = vec2<f32>(0.0, 0.0);
var<private> global22: vec2<f32> = vec2<f32>(0.0, 0.0);
var<private> global23: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
var<private> global24: i32 = 0;
var<private> global25: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
var<private> global26: u32 = 0u;
var<private> global27: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
var<private> global28: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
var<private> global29: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
var<private> global30: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
var<private> global31: i32 = 0;
var<private> global32: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
var<private> global33: i32 = 0;
var<private> global34: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
var<private> global35: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
var<private> global36: f32 = 0.0;
var<private> global37: u32 = 0u;
var<private> global38: i32 = 0;
var<private> global39: i32 = 0;
var<private> global40: vec2<f32> = vec2<f32>(0.0, 0.0);
var<private> global41: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
var<private> global42: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
var<private> global43: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);
var<private> global44: bool = false;
var<private> global45: f32 = 0.0;
var<private> global46: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
var<private> global47: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);

fn doConvert() {
    var local: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
    var local1: u32 = 0u;
    var local2: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    var local3: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
    var local4: u32 = 0u;
    var local5: i32 = 0;
    var local6: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
    var local7: vec2<f32> = vec2<f32>(0.0, 0.0);
    var temp: vec3<f32>;

    let e94: f32 = b_b;
    let e98: vec3<f32> = vec3<f32>(vec3<f32>(0.0, 0.3333333432674408, 0.6666666865348816).x, 0.6666666865348816, vec3<f32>(0.0, 0.3333333432674408, 0.6666666865348816).z);
    let e99: f32 = s_g;
    local7 = vec2<f32>(0.0, 0.0);
    let e102: f32 = ((1.0 - e99) * e94);
    local6 = vec3<f32>(0.30000001192092896, 0.30000001192092896, 0.30000001192092896);
    let e106: vec3<f32> = vec3<f32>(40.0, vec3<f32>(0.0, 0.0, 0.0).y, vec3<f32>(0.0, 0.0, 0.0).z);
    let e107: vec3<f32> = local6;
    let e110: mat2x2<f32> = mat2x2<f32>(mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0))[0], vec2<f32>(0.0, 0.0));
    let e111: f32 = b_b;
    let e115: vec3<f32> = vec3<f32>(e98.x, e98.y, 6.0);
    global10 = 0.30000001192092896;
    let e116: f32 = global10;
    let e121: f32 = b_b;
    let e122: f32 = s_g;
    let e123: f32 = (1.0 - e122);
    let e130: f32 = (e121 * e123);
    local5 = 0;
    local4 = 2u;
    let e146: f32 = h_r;
    let e147: vec3<f32> = vec3<f32>(e146);
    let e148: vec3<f32> = (e147 - vec3<f32>(0.0, 0.3333333432674408, 0.6666666865348816));
    local3 = vec3<f32>(0.0, 0.3333333432674408, 0.6666666865348816);
    let e151: vec3<f32> = local3;
    let e157: vec3<f32> = (abs((e148 * 6.0)) - vec3<f32>(3.0));
    let e158: vec3<f32> = abs(e157);
    let e159: vec3<f32> = vec3<f32>(1.0);
    let e160: vec3<f32> = (e158 - e159);
    local2 = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    let e166: vec3<f32> = vec3<f32>(1.0);
    let e176: vec3<f32> = (clamp(e160, vec3<f32>(0.0), e166) * (e111 - e130));
    let e177: vec3<f32> = vec3<f32>(e102);
    local1 = 0u;
    let e181: vec3<f32> = vec3<f32>(e166.x, e166.y, e102);
    temp = (e176 + e177);
    let e192: vec4<f32> = vec4<f32>(vec4<f32>(0.0, 0.0, 0.0, 0.0).x, 0.5, vec4<f32>(0.0, 0.0, 0.0, 0.0).z, vec4<f32>(0.0, 0.0, 0.0, 0.0).w);
    let e194: f32 = temp[0u];
    h_r = e194;
    local = e158;
    let e210: f32 = temp[1u];
    s_g = e210;
    global11 = e177;
    let e225: f32 = temp[2u];
    b_b = e225;
    global12 = vec2<f32>(0.0, 0.0);
    return;
}

fn computeColorf1vf2(c: ptr<function, f32>, position: ptr<function, vec2<f32>>) -> vec3<f32> {
    var local8: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
    var local9: u32 = 0u;
    var local10: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    var local11: vec2<f32> = vec2<f32>(0.0, 0.0);

    let e91: f32 = (*c);
    let e96: f32 = fract(e91);
    let e100: vec3<f32> = vec3<f32>(e96, vec3<f32>(0.0, 0.3333333432674408, 0.6666666865348816).y, vec3<f32>(0.0, 0.3333333432674408, 0.6666666865348816).z);
    h_r = e96;
    s_g = 1.0;
    let e102: f32 = global.time;
    let e104: f32 = (0.5 * sin(e102));
    let e106: f32 = ((0.5 + e104) + 0.5);
    b_b = e106;
    doConvert();
    let e117: vec3<f32> = vec3<f32>(vec3<f32>(0.30000001192092896, 0.30000001192092896, 0.30000001192092896).x, vec3<f32>(0.30000001192092896, 0.30000001192092896, 0.30000001192092896).y, 0.5);
    global13 = 1u;
    let e120: vec2<f32> = vec2<f32>(vec2<f32>(0.5, 0.5).x, e106);
    let e124: vec2<f32> = vec2<f32>(vec2<f32>(0.5, 0.5).x, e104);
    let e125: f32 = (*position)[1u];
    local11 = vec2<f32>(0.0, 0.0);
    let e126: vec2<f32> = local11;
    let e127: f32 = (1.0 / e125);
    let e128: f32 = s_g;
    let e132: vec2<f32> = vec2<f32>(0.6666666865348816, e120.y);
    local10 = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    s_g = (e128 * e127);
    let e143: f32 = (*position)[0u];
    let e145: f32 = h_r;
    let e153: vec3<f32> = vec3<f32>(vec3<f32>(0.0, 0.0, 0.0).x, e106, vec3<f32>(0.0, 0.0, 0.0).z);
    h_r = ((1.0 / e143) * e145);
    let e158: f32 = (*position)[1u];
    global14 = vec3<f32>(0.0, 0.3333333432674408, 0.6666666865348816);
    let e160: vec3<f32> = global14;
    let e165: f32 = (*position)[0u];
    if ((abs((e158 - e165)) < 0.5)) {
        let e175: f32 = b_b;
        b_b = clamp(0.0, 1.0, (3.0 * e175));
    }
    let e186: f32 = h_r;
    let e190: vec3<f32> = vec3<f32>(e153.x, 40.0, e153.z);
    local9 = 0u;
    let e196: f32 = s_g;
    let e201: f32 = b_b;
    local8 = vec3<f32>(0.0, 0.0, 0.0);
    return vec3<f32>(e186, e196, e201);
}

fn defaultColor() -> vec3<f32> {
    return vec3<f32>(0.0, 0.0, 0.0);
}

fn drawShapevf2vf2vf3(pos: ptr<function, vec2<f32>>, square: ptr<function, vec2<f32>>, setting: ptr<function, vec3<f32>>) -> vec3<f32> {
    var local12: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    var local13: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    var local14: i32 = 0;
    var local15: vec2<f32> = vec2<f32>(0.0, 0.0);
    var local16: i32 = 0;
    var local17: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    var local18: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
    var local19: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    var local20: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    var local21: vec2<f32> = vec2<f32>(0.0, 0.0);
    var local22: bool = false;
    var local23: u32 = 0u;
    var c1: bool;
    var c2: bool;
    var c3: bool;
    var c4: bool;
    var c5: bool;
    var param: f32;
    var param1: vec2<f32>;
    var c6: bool;
    var param2: f32;
    var param3: vec2<f32>;
    var c7: bool;
    var param4: f32;
    var param5: vec2<f32>;
    var c8: bool;
    var param6: f32;
    var param7: vec2<f32>;

    let e118: vec2<f32> = vec2<f32>(0.10000000149011612, vec2<f32>(0.0, 0.0).y);
    let e120: f32 = (*pos)[0u];
    let e123: vec2<f32> = vec2<f32>(0.009999999776482582, vec2<f32>(0.5, 0.5).y);
    let e125: f32 = (*setting)[0u];
    local23 = 1u;
    let e127: f32 = (e120 - e125);
    let e131: vec3<f32> = vec3<f32>(0.0, vec3<f32>(0.0, 0.0, 0.0).y, vec3<f32>(0.0, 0.0, 0.0).z);
    let e133: f32 = (*square)[0u];
    global15 = vec3<f32>(0.30000001192092896, 0.30000001192092896, 0.30000001192092896);
    let e139: mat2x2<f32> = mat2x2<f32>(mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0))[0], vec2<f32>(1.0, mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0))[1].y));
    let e140: vec3<f32> = global15;
    let e141: bool = (e127 < e133);
    c1 = e141;
    let e145: vec3<f32> = vec3<f32>(e131.x, 0.30000001192092896, e131.z);
    let e146: bool = c1;
    global16 = 1u;
    let e152: vec4<f32> = vec4<f32>(e120, vec4<f32>(0.0, 0.0, 0.0, 0.0).y, vec4<f32>(0.0, 0.0, 0.0, 0.0).z, vec4<f32>(0.0, 0.0, 0.0, 0.0).w);
    let e153: bool = !(e146);
    global17 = e153;
    let e157: vec3<f32> = vec3<f32>(0.3333333432674408, e140.y, e140.z);
    if (e153) {
        let e159: vec3<f32> = defaultColor();
        return e159;
    }
    let e167: vec3<f32> = vec3<f32>(vec3<f32>(0.0, 0.0, 0.0).x, 4.0, vec3<f32>(0.0, 0.0, 0.0).z);
    global18 = vec2<f32>(0.0, 0.0);
    let e172: vec2<f32> = global18;
    let e176: vec3<f32> = vec3<f32>(vec3<f32>(0.30000001192092896, 0.30000001192092896, 0.30000001192092896).x, 0.009999999776482582, vec3<f32>(0.30000001192092896, 0.30000001192092896, 0.30000001192092896).z);
    let e178: f32 = (*pos)[0u];
    let e180: f32 = (*setting)[0u];
    let e185: vec4<f32> = vec4<f32>(vec4<f32>(0.0, 0.0, 0.0, 0.0).x, vec4<f32>(0.0, 0.0, 0.0, 0.0).y, vec4<f32>(0.0, 0.0, 0.0, 0.0).z, 0.30000001192092896);
    let e186: f32 = (e180 + e178);
    let e189: vec2<f32> = vec2<f32>(0.0, vec2<f32>(0.0, 0.0).y);
    let e191: f32 = (*square)[0u];
    let e195: vec2<f32> = vec2<f32>(e118.x, 0.10000000149011612);
    global19 = 1u;
    let e199: vec3<f32> = vec3<f32>(e186, e167.y, e167.z);
    c2 = (e186 > e191);
    let e204: vec3<f32> = vec3<f32>(vec3<f32>(0.0, 0.0, 0.0).x, vec3<f32>(0.0, 0.0, 0.0).y, 0.009999999776482582);
    let e205: bool = c2;
    if (!(e205)) {
        let e212: vec3<f32> = defaultColor();
        return e212;
    }
    local22 = e141;
    let e215: f32 = (*pos)[1u];
    let e219: vec3<f32> = vec3<f32>(e167.x, e167.y, e180);
    global20 = e172;
    let e221: vec2<f32> = global20;
    let e225: vec3<f32> = vec3<f32>(e219.x, e219.y, e215);
    let e226: f32 = (*setting)[0u];
    let e227: f32 = (e215 - e226);
    let e229: f32 = (*square)[1u];
    let e234: vec3<f32> = vec3<f32>(vec3<f32>(0.0, 0.0, 0.0).x, e191, vec3<f32>(0.0, 0.0, 0.0).z);
    c3 = (e227 < e229);
    let e235: bool = c3;
    let e238: vec2<f32> = vec2<f32>(0.10000000149011612, vec2<f32>(0.5, 0.5).y);
    global21 = e221;
    let e243: vec2<f32> = global21;
    if (!(e235)) {
        let e245: vec3<f32> = defaultColor();
        return e245;
    }
    let e251: vec2<f32> = vec2<f32>(e172.x, e178);
    local21 = e221;
    let e252: vec2<f32> = local21;
    let e256: vec3<f32> = vec3<f32>(e127, e225.y, e225.z);
    let e258: f32 = (*pos)[1u];
    global22 = e252;
    let e261: vec2<f32> = vec2<f32>(40.0, e118.y);
    let e262: vec2<f32> = global22;
    local20 = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    let e268: mat2x2<f32> = local20;
    let e269: f32 = (*setting)[0u];
    let e274: f32 = (e258 + e269);
    global23 = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    let e277: vec2<f32> = vec2<f32>(vec2<f32>(0.0, 0.0).x, e125);
    let e278: mat2x2<f32> = global23;
    let e282: vec3<f32> = vec3<f32>(vec3<f32>(0.0, 0.3333333432674408, 0.6666666865348816).x, vec3<f32>(0.0, 0.3333333432674408, 0.6666666865348816).y, 10.0);
    let e284: f32 = (*square)[1u];
    let e289: vec4<f32> = vec4<f32>(vec4<f32>(0.0, 0.0, 0.0, 0.0).x, e215, vec4<f32>(0.0, 0.0, 0.0, 0.0).z, vec4<f32>(0.0, 0.0, 0.0, 0.0).w);
    global24 = 35;
    let e290: i32 = global24;
    c4 = (e274 > e284);
    local19 = e278;
    let e292: mat2x2<f32> = local19;
    let e296: vec3<f32> = vec3<f32>(e157.x, 10.0, e157.z);
    let e297: bool = c4;
    let e301: vec3<f32> = vec3<f32>(vec3<f32>(0.0, 0.0, 0.0).x, vec3<f32>(0.0, 0.0, 0.0).y, 0.30000001192092896);
    if (!(e297)) {
        local18 = vec3<f32>(0.30000001192092896, 0.30000001192092896, 0.30000001192092896);
        let e311: vec3<f32> = defaultColor();
        return e311;
    }
    let e319: vec2<f32> = vec2<f32>(e178, e195.y);
    global25 = e268;
    let e325: mat2x2<f32> = global25;
    let e332: mat2x2<f32> = mat2x2<f32>(vec2<f32>(e325[0].x, 6.0), e325[1]);
    let e333: f32 = (*pos)[0u];
    let e338: f32 = (*setting)[0u];
    let e345: vec2<f32> = vec2<f32>(0.009999999776482582, e221.y);
    let e346: f32 = (*setting)[1u];
    let e352: mat2x2<f32> = mat2x2<f32>(e139[0], vec2<f32>(0.6666666865348816, e139[1].y));
    let e353: f32 = (e338 - e346);
    let e357: vec3<f32> = vec3<f32>(e199.x, e199.y, e353);
    let e358: f32 = (e333 - e353);
    let e364: vec4<f32> = vec4<f32>(e289.x, e284, e289.z, e289.w);
    local17 = e268;
    let e365: mat2x2<f32> = local17;
    let e366: f32 = (*square)[0u];
    global26 = 1u;
    c5 = (e358 < e366);
    let e377: bool = c5;
    if (!(e377)) {
        let e384: f32 = (*setting)[2u];
        param = (e384 / 40.0);
        let e389: vec2<f32> = (*pos);
        global27 = vec3<f32>(0.0, 0.0, 0.0);
        param1 = e389;
        let e400: vec3<f32> = computeColorf1vf2((&param), (&param1));
        return e400;
    }
    global28 = e278;
    let e403: vec2<f32> = vec2<f32>(e261.x, e180);
    let e404: mat2x2<f32> = global28;
    let e410: mat2x2<f32> = mat2x2<f32>(vec2<f32>(e346, e325[0].y), e325[1]);
    let e412: f32 = (*pos)[0u];
    let e415: vec2<f32> = vec2<f32>(e238.x, e133);
    local16 = 35;
    let e418: f32 = (*setting)[0u];
    let e424: f32 = (*setting)[1u];
    let e429: f32 = (e412 + (e418 - e424));
    let e431: f32 = (*square)[0u];
    global29 = e140;
    let e432: vec3<f32> = global29;
    let e440: vec3<f32> = vec3<f32>(e296.x, e366, e296.z);
    c6 = (e429 > e431);
    let e443: vec2<f32> = vec2<f32>(e345.x, e338);
    let e444: bool = c6;
    if (!(e444)) {
        let e450: f32 = (*setting)[2u];
        let e451: f32 = (e450 / 40.0);
        param2 = e451;
        global30 = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
        let e462: vec2<f32> = (*pos);
        param3 = e462;
        let e467: vec3<f32> = computeColorf1vf2((&param2), (&param3));
        global31 = 0;
        return e467;
    }
    global32 = e292;
    let e476: mat2x2<f32> = global32;
    let e481: vec3<f32> = vec3<f32>(e133, e225.y, e225.z);
    let e482: f32 = (*pos)[1u];
    let e491: f32 = (*setting)[0u];
    let e497: f32 = (*setting)[1u];
    local15 = e252;
    let e509: f32 = (*square)[1u];
    let e516: vec2<f32> = vec2<f32>(e443.x, 0.10000000149011612);
    c7 = ((e482 - (e491 - e497)) < e509);
    let e517: bool = c7;
    if (!(e517)) {
        let e523: f32 = (*setting)[2u];
        let e524: f32 = (e523 / 40.0);
        param4 = e524;
        global33 = 35;
        let e537: vec2<f32> = (*pos);
        param5 = e537;
        local14 = 35;
        let e551: vec3<f32> = computeColorf1vf2((&param4), (&param5));
        return e551;
    }
    let e559: vec3<f32> = vec3<f32>(e204.x, e418, e204.z);
    global34 = vec3<f32>(0.0, 0.0, 0.0);
    let e565: f32 = (*pos)[1u];
    let e574: f32 = (*setting)[0u];
    local13 = e476;
    let e588: f32 = (*setting)[1u];
    global35 = e278;
    global36 = e482;
    global37 = 2u;
    let e622: f32 = (*square)[1u];
    let e625: vec2<f32> = vec2<f32>(e251.x, e180);
    c8 = ((e565 + (e574 - e588)) > e622);
    global38 = e290;
    let e639: bool = c8;
    if (!(e639)) {
        local12 = e365;
        let e654: f32 = (*setting)[2u];
        param6 = (e654 / 40.0);
        let e659: vec2<f32> = (*pos);
        param7 = e659;
        let e663: vec3<f32> = computeColorf1vf2((&param6), (&param7));
        return e663;
    }
    let e664: vec3<f32> = defaultColor();
    return e664;
}

fn computePointmf22(rotationMatrix: ptr<function, mat2x2<f32>>) -> vec3<f32> {
    var local24: i32 = 0;
    var local25: u32 = 0u;
    var local26: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);
    var local27: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
    var local28: i32 = 0;
    var local29: i32 = 0;
    var local30: i32 = 0;
    var local31: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
    var local32: vec2<f32> = vec2<f32>(0.0, 0.0);
    var local33: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    var local34: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);
    var local35: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    var local36: i32 = 0;
    var local37: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
    var aspect: vec2<f32>;
    var position1: vec2<f32>;
    var center: vec2<f32>;
    var result: vec3<f32>;
    var i: i32;
    var d: vec3<f32>;
    var param8: vec2<f32>;
    var param9: vec2<f32>;
    var param10: vec3<f32>;
    var local38: f32;
    var local39: vec3<f32>;

    global39 = 35;
    let e114: i32 = global39;
    let e116: vec2<f32> = global1.resolution;
    let e119: vec2<f32> = vec2<f32>(vec2<f32>(0.0, 0.0).x, 0.3333333432674408);
    local37 = vec3<f32>(0.0, 0.0, 0.0);
    let e120: vec3<f32> = local37;
    let e123: f32 = global1.resolution[0u];
    let e126: f32 = global1.resolution[1u];
    let e127: f32 = min(e123, e126);
    local36 = e114;
    let e131: i32 = local36;
    let e134: mat2x2<f32> = mat2x2<f32>(mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0))[0], e116);
    let e135: vec2<f32> = vec2<f32>(e127);
    global40 = vec2<f32>(0.5, 0.5);
    let e138: vec2<f32> = vec2<f32>(3.0, vec2<f32>(0.0, 0.0).y);
    let e140: vec2<f32> = (e116 / e135);
    let e143: vec2<f32> = vec2<f32>(e135.x, e126);
    local35 = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    let e147: mat2x2<f32> = local35;
    aspect = e140;
    let e148: vec4<f32> = gl_FragCoord1;
    let e151: vec2<f32> = vec2<f32>(40.0, e119.y);
    let e154: vec2<f32> = global1.resolution;
    let e157: vec2<f32> = vec2<f32>(e154.x, 0.0);
    local34 = e148;
    let e160: vec2<f32> = vec2<f32>(e119.x, e127);
    let e161: vec4<f32> = local34;
    let e162: vec2<f32> = (e148.xy / e154);
    local33 = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    let e167: mat2x2<f32> = local33;
    let e168: vec2<f32> = aspect;
    position1 = (e168 * e162);
    local32 = e154;
    let e176: vec2<f32> = vec2<f32>(e157.x, 3.0);
    let e177: vec2<f32> = aspect;
    center = (e177 * vec2<f32>(0.5, 0.5));
    let e182: mat2x2<f32> = (*rotationMatrix);
    local31 = vec3<f32>(0.30000001192092896, 0.30000001192092896, 0.30000001192092896);
    let e193: vec2<f32> = position1;
    global41 = e167;
    let e196: mat2x2<f32> = mat2x2<f32>(mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0))[0], vec2<f32>(e143.x, e123));
    position1 = (e193 * e182);
    let e199: mat2x2<f32> = (*rotationMatrix);
    local30 = 0;
    let e206: vec2<f32> = center;
    let e209: vec2<f32> = vec2<f32>(e140.x, 0.30000001192092896);
    local29 = e131;
    center = (e206 * e199);
    result = vec3<f32>(0.0, 0.0, 0.0);
    i = 35;
    loop {
        global42 = e182;
        let e223: vec4<f32> = vec4<f32>(e148.x, e148.y, 0.0, e148.w);
        let e224: i32 = i;
        let e225: bool = (e224 >= 0);
        local28 = e224;
        if (e225) {
            let e230: vec2<f32> = center;
            global43 = vec4<f32>(0.0, 0.0, 0.0, 0.0);
            let e241: vec2<f32> = vec2<f32>(0.3333333432674408, e209.y);
            let e242: i32 = i;
            let e245: vec2<f32> = vec2<f32>(e230.x, 4.0);
            let e246: f32 = f32(e242);
            let e247: f32 = (e246 / 10.0);
            global44 = e225;
            let e256: f32 = global.time;
            let e257: f32 = (e247 + e256);
            let e259: f32 = (sin(e257) / 4.0);
            let e264: vec2<f32> = (e230 + vec2<f32>(e259, 0.0));
            let e265: i32 = i;
            global45 = e247;
            let e270: f32 = global45;
            let e273: mat2x2<f32> = mat2x2<f32>(e134[0], e264);
            local27 = e120;
            let e283: f32 = (f32(e265) / 100.0);
            let e286: i32 = i;
            global46 = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
            let e291: f32 = f32(e286);
            let e295: vec3<f32> = vec3<f32>((sin(e283) + 0.009999999776482582), 0.009999999776482582, e291);
            global47 = e161;
            let e301: vec2<f32> = vec2<f32>(vec2<f32>(0.0, 0.0).x, e246);
            let e303: vec2<f32> = position1;
            param8 = e303;
            param9 = e264;
            let e317: vec2<f32> = vec2<f32>(e301.x, 0.30000001192092896);
            param10 = e295;
            let e321: vec3<f32> = drawShapevf2vf2vf3((&param8), (&param9), (&param10));
            d = e321;
            let e327: vec2<f32> = vec2<f32>(10.0, e177.y);
            let e328: vec3<f32> = d;
            local38 = e270;
            local39 = e321;
            if ((length(e328) <= 0.0)) {
                continue;
            }
            let e340: vec3<f32> = d;
            result = vec3<f32>(e340.x, e340.y, e340.z);
            continue;
        } else {
            break;
        }
        continuing {
            local26 = e161;
            let e360: f32 = local38;
            let e362: vec3<f32> = local39;
            let e367: i32 = i;
            i = (e367 - 1);
            local25 = 2u;
        }
    }
    local24 = e131;
    let e379: vec3<f32> = result;
    return e379;
}

fn main1() {
    var local40: mat2x2<f32> = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    var local41: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
    var local42: vec2<f32> = vec2<f32>(0.0, 0.0);
    var local43: u32 = 0u;
    var local44: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
    var local45: vec2<f32> = vec2<f32>(0.0, 0.0);
    var local46: vec2<f32> = vec2<f32>(0.0, 0.0);
    var local47: f32 = 0.0;
    var local48: vec2<f32> = vec2<f32>(0.0, 0.0);
    var angle: f32;
    var rotationMatrix1: mat2x2<f32>;
    var point1: vec3<f32>;
    var param11: mat2x2<f32>;
    var rotationMatrix2: mat2x2<f32>;
    var point2: vec3<f32>;
    var param12: mat2x2<f32>;
    var rotationMatrix3: mat2x2<f32>;
    var point3: vec3<f32>;
    var param13: mat2x2<f32>;
    var mixed: vec3<f32>;

    let e108: mat2x2<f32> = mat2x2<f32>(mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0))[0], vec2<f32>(0.0, 0.0));
    let e109: f32 = global.time;
    let e110: f32 = sin(e109);
    let e111: f32 = (e110 * 0.10000000149011612);
    let e114: vec2<f32> = vec2<f32>(vec2<f32>(0.0, 0.0).x, e111);
    angle = e111;
    let e119: vec4<f32> = vec4<f32>(vec4<f32>(0.0, 0.0, 0.0, 0.0).x, vec4<f32>(0.0, 0.0, 0.0, 0.0).y, vec4<f32>(0.0, 0.0, 0.0, 0.0).z, e109);
    let e120: f32 = angle;
    global2 = 40.0;
    let e121: f32 = global2;
    local48 = vec2<f32>(0.5, 0.5);
    let e130: vec2<f32> = local48;
    let e131: f32 = angle;
    let e135: f32 = cos(e131);
    let e136: f32 = -(e135);
    local47 = e121;
    let e142: f32 = local47;
    let e146: f32 = angle;
    let e149: vec2<f32> = vec2<f32>(e131, e114.y);
    let e150: f32 = cos(e146);
    let e154: f32 = angle;
    let e155: f32 = sin(e154);
    let e156: vec2<f32> = vec2<f32>(sin(e120), e136);
    local46 = e130;
    let e162: vec2<f32> = local46;
    let e163: mat2x2<f32> = mat2x2<f32>(e156, vec2<f32>(e150, e155));
    rotationMatrix1 = e163;
    let e164: mat2x2<f32> = rotationMatrix1;
    param11 = e164;
    let e165: vec3<f32> = computePointmf22((&param11));
    local45 = vec2<f32>(0.0, 0.0);
    point1 = e165;
    global3 = e164;
    let e182: vec3<f32> = vec3<f32>(vec3<f32>(0.30000001192092896, 0.30000001192092896, 0.30000001192092896).x, 100.0, vec3<f32>(0.30000001192092896, 0.30000001192092896, 0.30000001192092896).z);
    let e183: mat2x2<f32> = global3;
    let e184: mat2x2<f32> = rotationMatrix1;
    let e187: vec2<f32> = vec2<f32>(0.6666666865348816, e162.y);
    let e188: mat2x2<f32> = rotationMatrix1;
    local44 = vec3<f32>(0.30000001192092896, 0.30000001192092896, 0.30000001192092896);
    let e195: vec2<f32> = vec2<f32>(e187.x, 0.5);
    let e199: vec2<f32> = vec2<f32>(e149.x, e135);
    rotationMatrix2 = (e184 * e188);
    let e206: mat2x2<f32> = rotationMatrix2;
    param12 = e206;
    let e212: vec3<f32> = computePointmf22((&param12));
    let e215: vec2<f32> = vec2<f32>(1.0, e114.y);
    point2 = e212;
    global4 = mat2x2<f32>(vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    let e220: mat2x2<f32> = rotationMatrix1;
    let e224: mat2x2<f32> = rotationMatrix1;
    global5 = e224;
    let e225: mat2x2<f32> = global5;
    let e228: vec2<f32> = vec2<f32>(e156.x, e131);
    let e229: mat2x2<f32> = (e220 * e224);
    global6 = 0u;
    let e237: mat2x2<f32> = rotationMatrix1;
    global7 = 0u;
    let e248: u32 = global7;
    local43 = e248;
    rotationMatrix3 = (e229 * e237);
    global8 = e162;
    let e254: vec2<f32> = global8;
    let e259: mat2x2<f32> = rotationMatrix3;
    param13 = e259;
    let e266: vec3<f32> = computePointmf22((&param13));
    let e269: mat2x2<f32> = mat2x2<f32>(e164[0], vec2<f32>(e228.x, e131));
    point3 = e266;
    let e270: vec3<f32> = point1;
    let e271: vec3<f32> = point2;
    let e278: vec3<f32> = mix(e270, e271, vec3<f32>(0.30000001192092896, 0.30000001192092896, 0.30000001192092896));
    mixed = e278;
    let e283: vec3<f32> = mixed;
    let e288: vec3<f32> = point3;
    local42 = vec2<f32>(0.5, 0.5);
    mixed = mix(e283, e288, vec3<f32>(0.30000001192092896, 0.30000001192092896, 0.30000001192092896));
    let e300: vec3<f32> = mixed;
    local41 = e283;
    global9 = 0.30000001192092896;
    local40 = e188;
    GLF_color = vec4<f32>(e300.x, e300.y, e300.z, 1.0);
    return;
}

[[stage(fragment)]]
fn main([[builtin(position)]] gl_FragCoord: vec4<f32>) -> [[location(0)]] vec4<f32> {
    gl_FragCoord1 = gl_FragCoord;
    main1();
    let e3: vec4<f32> = GLF_color;
    return e3;
}
